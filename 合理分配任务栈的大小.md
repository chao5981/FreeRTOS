  请学完"创建多个动态任务"再来看此文章
  
  在创建任务的时候，无论是利用动态创建任务函数还是静态创建任务函数，都需要我们输入任务堆栈的大小。例如：在这个版本的freertos中，传入的任务栈大小是字，如果我们传入了128，那么这个任务的大小就是128*4=512bite。

  但是在裸机开发中，SRAM的内存终究有限，我们不可能每一个任务都分配太大的内存，这里就要求我们根据具体任务在执行过程中的栈大小去判断一个任务需要分配多少的栈空间。

  最严谨的办法肯定是直接去阅读反汇编代码，但是这样的话编程的速率严重降低，那玩意是给人读的嘛？还好freertos给我们提供了相关的函数，去监测任务栈的使用情况，我们将这种方法称之为:高水位线法

  高水位线法：在大多数嵌入式系统中，堆栈是向下生长的（从高地址向低地址使用），初始状态：堆栈指针（SP）指向堆栈顶部（最大地址）。运行中：随着函数调用和局部变量的使用，SP 逐渐向低地址移动，高水位线：SP 曾经到
达的最低地址（即堆栈使用的最深处）。高水位线表示任务运行过程中堆栈的最大使用量，通过 当前堆栈大小 - 高水位线，可以计算出实际需要的堆栈大小。

  下面讲解高水位线法的使用方法。

  1.在FreeRTOS.h中把INCLUDE_uxTaskGetStackHighWaterMark宏定义修改为1.

  2.先根据具体经验，给任务分配一个比较大的任务栈
  <img width="564" height="149" alt="image" src="https://github.com/user-attachments/assets/545b4aef-502f-4fb1-8724-99f7e5c28593" />

  3.创建一个TaskMonitor函数，在这个函数中调用uxTaskGetStackHighWaterMark()函数去监测任务栈的使用情况
  <img width="621" height="316" alt="image" src="https://github.com/user-attachments/assets/c1091a42-6003-4bd9-abea-89c42fde5a3c" />

  
  4.打印出来即可

  在我"创建多个动态任务"中，我打印出来的结果如下：

  <img width="703" height="251" alt="c4c8f821ce5a9410822afa94bb7eb172" src="https://github.com/user-attachments/assets/fc58f3fb-59be-44d2-aea2-deea803d14b8" />

  对于一个任务，我们要预留30%的栈余量，以保证程序的正常运行，因此：

      LED1 Task:合适的任务栈大小：88(bite)*1.3/4=28.6(word)。
      LED2 Task:合适的任务栈大小：88(bite)*1.3/4=28.6(word)。
      USART_Task:合适的任务栈大小：176(bite)*1.3/4=57.2(word).

  所以，创建任务时任务栈大小重新修改如下：
  <img width="735" height="354" alt="image" src="https://github.com/user-attachments/assets/52e28d8f-376c-41db-9b72-36123c2e73f6" />

  最后打印情况如下：
  <img width="715" height="248" alt="fc621eed193b6e79b53c856a9fd3bdc6" src="https://github.com/user-attachments/assets/2d62de4c-24e3-4fb1-b34c-f6ac7e38ea6d" />

  可以看到，USART莫名其妙又多用了一点任务栈，但无妨，我们已经预留了30%的余量，所以它不会超。



  
