上一节我们着重讲解了二值信号量，这一节主要讲解互斥量。

  互斥量有俩种，一直就是互斥量，一种就是递归互斥量。互斥量本质和二值信号量一样，当互斥量被任务持有时，该互斥量处于闭锁状态，这个任务获得互斥量的所有权。当该任务释放这个互斥量时，该互斥量处于开锁状态，任务失去
该互斥量的所有权。当一个任务持有互斥量时，其他任务将不能再对该互斥量进行开锁或持有。必须得等这个任务释放这个互斥量才可以占用。而递归互斥量的本质就是持有该互斥量的任务也能够再次获得这个锁而不被挂起，这就是递归
访问。

  用于互锁的互斥量可以充当保护资源的令牌，当一个任务希望访问某个资源时，它必须先获取令牌。当任务使用完资源后，必须还回令牌，以便其它任务可以访问该资源。

  但如果单纯是只是"互斥"这一个点的话，在freertos的实际运行中，必然会有一些麻烦，我给大家举个例子。

  现在分别有三个优先级L任务(Low),M任务(Mid),H任务(High),现在L任务拿到了互斥量，互斥量上了锁，之后H任务被唤醒，它也需要互斥量，但是互斥量被L任务占用，所以H任务不得不等待，H任务被挂起。如果在L任务拿到互斥量后
，任务执行的过程中L任务被挂起，H任务由于没得到互斥量也被挂起，那么M任务就被执行。

  因此你发现了没有，H任务为了等待L任务释放互斥量，要等待L任务和M任务执行完才可以正常运行，这就不符合高优先级优先的原则，这对我们操作系统是致命伤。这种现象也被叫做"优先级翻转"

  <img width="737" height="394" alt="image" src="https://github.com/user-attachments/assets/fb6764ee-15fe-468b-b97b-cb2225055fb3" />


  为了尽可能避免这种优先级翻转的现象，freertos在互斥量的相关函数中进行了如下处理:L拿到互斥量后，暂时把L任务的优先级提升到High，这样在L任务在占用互斥量的过程中被挂起时，M任务也不能进行抢占CPU，直到L任务释放
互斥量，H任务就可以正常运行。这个叫做"优先级继承"

<img width="753" height="398" alt="image" src="https://github.com/user-attachments/assets/d6b70e19-7cd6-479c-a6e1-529f8e2c9d17" />

正因为互斥量具有优先级继承的机制，所以只在任务起作用，在中断的上下文环境毫无意义。

再次重申互斥量的应用场景

互斥量：可能会引起优先级翻转的情况;相互占用同一临界资源的应用场景，互斥量可被用于对临界资源的保护从而实现独占式访问

递归互斥量：任务可能会多次获取互斥量的情况下。这样可以避免同一任务多次递归持有而造成死锁的问题

<img width="832" height="428" alt="image" src="https://github.com/user-attachments/assets/c0153824-ca4c-449a-8eb5-b422d3384019" />

在利用互斥量时，需要引入semphr.h头文件，并把configUSE_MUTEXES，configSUPPORT_DYNAMIC_ALLOCATION 定义为 1定义为1。

下面介绍互斥量相关函数：

